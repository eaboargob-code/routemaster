================================================================================
OFFLINE/CACHING LOGIC SCAN - RouteMASTER
================================================================================
Generated: 2025-01-27
Scope: Search for offline/caching logic patterns in the codebase

================================================================================
SUMMARY
================================================================================

The RouteMASTER application implements a comprehensive offline caching system
primarily focused on QR scanning functionality and student data. The app uses
IndexedDB for offline storage and includes Firebase messaging service worker
for push notifications.

Key Findings:
- Custom IndexedDB-based offline cache system (src/lib/offlineCache.ts)
- localStorage usage for supervisor mode and audit logs
- Firebase messaging service worker for background notifications
- Profile caching using in-memory Map
- No Firebase offline persistence (enableIndexedDbPersistence) found
- No network status detection (navigator.onLine) found
- No next-pwa or workbox implementation found

================================================================================
DETAILED FINDINGS
================================================================================

1. INDEXEDDB OFFLINE CACHE SYSTEM
================================================================================

File: src/lib/offlineCache.ts
Lines: 1-355

Context:
```typescript
interface OfflineCacheDB extends DBSchema {
  students: {
    key: string;
    value: StudentQRData & { schoolId: string; routeId?: string; cachedAt: number };
  };
  scanResults: {
    key: string;
    value: {
      id: string;
      studentId: string;
      studentName: string;
      action: 'boarding' | 'dropping';
      tripId: string;
      timestamp: number;
      synced: boolean;
    };
  };
}

class OfflineCache {
  private db: IDBPDatabase<OfflineCacheDB> | null = null;
  private readonly DB_NAME = 'RoutemasterOfflineCache';
  private readonly DB_VERSION = 1;

  async init(): Promise<void> {
    try {
      this.db = await openDB<OfflineCacheDB>(this.DB_NAME, this.DB_VERSION, {
        upgrade(db) {
          // Create students store
          if (!db.objectStoreNames.contains('students')) {
            const studentsStore = db.createObjectStore('students', { keyPath: 'id' });
            studentsStore.createIndex('schoolId', 'schoolId');
            studentsStore.createIndex('routeId', 'routeId');
          }

          // Create scan results store
          if (!db.objectStoreNames.contains('scanResults')) {
            const scanStore = db.createObjectStore('scanResults', { keyPath: 'id' });
            scanStore.createIndex('synced', 'synced');
            scanStore.createIndex('tripId', 'tripId');
          }
        },
      });
    } catch (error) {
      console.error('Failed to initialize offline cache:', error);
    }
  }
```

Key Methods:
- cacheStudents(): Cache student data for offline QR scanning
- getCachedStudents(): Retrieve cached students for offline use
- cacheScanResult(): Store scan results for later sync
- clearCache(): Clear all cached data
- getCacheStats(): Get cache statistics
- isOfflineModeAvailable(): Check if offline mode is ready

2. LOCALSTORAGE USAGE - SUPERVISOR MODE
================================================================================

File: src/lib/supervisorMode.ts
Lines: 51-182

Context:
```typescript
// Load existing session from localStorage
const savedSession = localStorage.getItem(this.STORAGE_KEY);
if (savedSession) {
  try {
    const parsed = JSON.parse(savedSession);
    this.currentSession = {
      ...parsed,
      startTime: new Date(parsed.startTime),
      lastActivity: new Date(parsed.lastActivity),
    };
  } catch (error) {
    console.error('Failed to parse saved supervisor session:', error);
    localStorage.removeItem(this.STORAGE_KEY);
  }
}

const savedAuditLog = localStorage.getItem(this.AUDIT_LOG_KEY);
if (savedAuditLog) {
  try {
    this.auditLog = JSON.parse(savedAuditLog).map((entry: any) => ({
      ...entry,
      timestamp: new Date(entry.timestamp),
    }));
  } catch (error) {
    console.error('Failed to parse saved audit log:', error);
    localStorage.removeItem(this.AUDIT_LOG_KEY);
  }
}
```

Storage Keys:
- STORAGE_KEY: 'supervisor_session' - Current supervisor session data
- AUDIT_LOG_KEY: 'supervisor_audit_log' - Audit trail for supervisor actions

3. PROFILE CACHING (IN-MEMORY)
================================================================================

File: src/lib/useProfile.tsx
Lines: 140-186

Context:
```typescript
const profileCache = new Map<string, UserProfile>();

// Return from cache if available to prevent re-fetching on every HMR
if (profileCache.has(u.uid)) {
  setState({ user: u, profile: profileCache.get(u.uid)!, loading: false, error: null });
  return;
}

// ... fetch profile logic ...

if(p) profileCache.set(u.uid, p);
```

Purpose: Prevents re-fetching user profiles during development (HMR)

4. QR SCANNER OFFLINE INTEGRATION
================================================================================

File: src/components/BulkQROperations.tsx
Lines: 28, 63-78

Context:
```typescript
import { getCachedStudentsForScanning } from '@/lib/offlineCache';

const [cachedStudents, setCachedStudents] = useState<StudentQRData[]>([]);

// Load cached students on component mount
useEffect(() => {
  const loadCachedStudents = async () => {
    try {
      const students = await getCachedStudentsForScanning();
      setCachedStudents(students);
    } catch (err) {
      console.error('Failed to load cached students:', err);
    }
  };

  loadCachedStudents();
}, []);
```

File: src/components/QRScanner.tsx
Lines: 36, 46

Context:
```typescript
cachedStudents?: StudentQRData[];
// ...
cachedStudents,
```

5. FIREBASE MESSAGING SERVICE WORKER
================================================================================

File: public/firebase-messaging-sw.js
Lines: 1-22

Context:
```javascript
/* global self, importScripts, firebase */
importScripts("https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js");
importScripts("https://www.gstatic.com/firebasejs/10.12.4/firebase-messaging-compat.js");

firebase.initializeApp({
  "projectId": "routemaster-admin-k1thy",
  "appId": "1:1071157867562:web:e6a8686b2849d515157f53",
  "storageBucket": "routemaster-admin-k1thy.firebasestorage.app",
  "apiKey": "AIzaSyAX-YaK7opiuKe8vQ0bH4RStr6UCVdlOEk",
  "authDomain": "routemaster-admin-k1thy.firebaseapp.com",
  "messagingSenderId": "1071157867562"
});

const messaging = firebase.messaging();

messaging.onBackgroundMessage(({ notification, data }) => {
  const title = (notification && notification.title) || "RouteMaster";
  const body  = (notification && notification.body) || "";
  self.registration.showNotification(title, {
    body, data, icon: "/icon-192.png", badge: "/badge.png"
  });
});
```

Purpose: Handles background push notifications when app is not active

6. FIRESTORE ERROR HANDLING
================================================================================

File: src/lib/firestore-helpers.ts
Lines: 5-24

Context:
```typescript
/**
 * A wrapper for onSnapshot that provides more informative error logging.
 * @param ref - The document reference or query to listen to.
 * @param label - A descriptive label for the listener for logging purposes.
 * @param onData - The callback function to handle successful snapshots.
 * @returns An unsubscribe function.
 */
export function listenWithPath(
    ref: DocumentReference | Query,
    label: string,
    onData: (snap: any) => void
) {
  try {
    return onSnapshot(ref, onData, (err) => {
      console.error(`[FIRESTORE-LISTEN ERROR] ${label}:`, err);
    });
  } catch (e) {
    console.error(`[FIRESTORE-START ERROR] ${label}:`, e);
    return () => {};
  }
}
```

Note: Generic error logging but no specific 'unavailable' code handling found

7. OFFLINE MODE TESTING
================================================================================

File: src/app/test-qr/page.tsx
Lines: 19, 146-149, 202

Context:
```typescript
const [testMode, setTestMode] = useState<'normal' | 'offline' | 'supervisor'>('normal');

// ...

<Button
  variant={testMode === 'offline' ? 'default' : 'outline'}
  onClick={() => setTestMode('offline')}
>
  Offline
</Button>

// ...

cachedStudents={testMode === 'offline' ? mockStudents : undefined}
```

Purpose: Test page includes offline mode simulation with mock data

================================================================================
PATTERNS NOT FOUND
================================================================================

1. Firebase Offline Persistence:
   - No enableIndexedDbPersistence() calls found
   - No initializeFirestore({localCache}) patterns found

2. Network Status Detection:
   - No navigator.onLine usage found
   - No addEventListener('online'/'offline') patterns found

3. PWA Framework Integration:
   - No next-pwa configuration found
   - No workbox usage found
   - No manifest.json found in public directory

4. Advanced Offline Error Handling:
   - No specific onSnapshot error handling for 'unavailable' code
   - No retry mechanisms for offline scenarios

5. Route/Map Caching:
   - No localStorage keys for route data found
   - No map tile caching found
   - No route preferences caching found

================================================================================
OFFLINE STRATEGY SUMMARY
================================================================================

The RouteMASTER application implements a focused offline strategy primarily
around QR scanning functionality:

1. **Student Data Caching**: Uses IndexedDB to cache student information for
   offline QR scanning operations

2. **Scan Result Queuing**: Stores scan results locally when offline for later
   synchronization when connection is restored

3. **Supervisor Session Persistence**: Uses localStorage to maintain supervisor
   session state and audit logs across browser sessions

4. **Background Notifications**: Firebase messaging service worker enables
   push notifications even when app is not active

5. **Profile Caching**: In-memory caching of user profiles to improve
   performance during development

The offline implementation is selective and focused on critical functionality
(QR scanning) rather than full offline capability for all app features.

================================================================================
RECOMMENDATIONS
================================================================================

1. Consider implementing Firebase offline persistence for broader offline support
2. Add network status detection for better offline UX
3. Implement retry mechanisms for failed operations
4. Consider adding route/map data caching for driver functionality
5. Add proper PWA manifest for app installation capabilities

================================================================================